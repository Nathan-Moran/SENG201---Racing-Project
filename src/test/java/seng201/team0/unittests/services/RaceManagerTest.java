package seng201.team0.unittests.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import seng201.team0.models.*;
import seng201.team0.services.GameEnvironment;
import seng201.team0.services.RaceManager;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class RaceManagerTest {

    private Race testRace;
    private Car playerCar;
    private List<OpponentCar> opponents;
    private OpponentCar firstOpponent;
    private RaceManager raceManager;
    private GameEnvironment gameEnvironment;

    private static final Route TEST_ROUTE = Route.DESERT_DRIFT;
    private static final Course TEST_COURSE = Course.DESERT;
    private static final Difficulty TEST_DIFFICULTY = Difficulty.EASY;

    private final double PLAYER_MGR_SPEED = 2.0;
    private final double PLAYER_MGR_FUEL_RATE = 0.05;

    @BeforeEach
    void setUp() {
        playerCar = new Car("Player TestCar", 0.7, 0.6, 0.9, 20, 1500);
        testRace = new Race(TEST_COURSE, TEST_ROUTE, TEST_DIFFICULTY);
        opponents = testRace.getOpponents(); // Use opponents generated by Race

        if (!opponents.isEmpty()) {
            firstOpponent = opponents.get(0); // Corrected from getFirst()
        } else {
            firstOpponent = new OpponentCar(0.1);
            opponents = new ArrayList<>(List.of(firstOpponent));
            testRace.setOpponents(opponents);
        }

        raceManager = new RaceManager(testRace, playerCar, opponents, PLAYER_MGR_SPEED, PLAYER_MGR_FUEL_RATE);

        gameEnvironment = new GameEnvironment();
        gameEnvironment.setName("JUnit Player");
        gameEnvironment.setDifficulty(TEST_DIFFICULTY);
        gameEnvironment.setBalance(10000);
        gameEnvironment.getPlayerInventory().setStarterCar(playerCar);
        gameEnvironment.setCurrentRace(testRace);
    }

    @Test
    void constructorInitializesCorrectly() {
        assertEquals(testRace, raceManager.getRace());
        assertEquals(playerCar, raceManager.getPlayerCar());
        assertEquals(opponents, raceManager.getOpponents());
        assertEquals(0, raceManager.getPlayerDistance());
        assertEquals(1.0, raceManager.getFuelLevel());
        assertFalse(raceManager.isRaceFinished());
        assertTrue(raceManager.isRacing());
        assertEquals(TEST_ROUTE.getRaceDuration(), raceManager.getRaceDurationSeconds());
    }

    @Test
    void advanceRaceTickPlayerMovesAndConsumesFuel() {
        raceManager.advanceRaceTick();
        assertEquals(PLAYER_MGR_SPEED, raceManager.getPlayerDistance(), "Player distance incorrect after 1 tick.");
        assertEquals(1.0 - PLAYER_MGR_FUEL_RATE, raceManager.getFuelLevel(), 0.00001, "Player fuel level incorrect.");
        if (firstOpponent != null) {
            assertEquals(firstOpponent.getSpeed(), firstOpponent.getCurrentDistance(), 0.001, "Opponent distance incorrect.");
        }
        assertEquals(0.5, raceManager.getTimeElapsedSeconds(), "Time elapsed incorrect.");
    }

    @Test
    void advanceRaceTickWhenWaiting() {
        raceManager.setWaiting(true, 2);
        double initialOpponentDist = (firstOpponent != null) ? firstOpponent.getCurrentDistance() : 0;

        raceManager.advanceRaceTick();
        assertEquals(0, raceManager.getPlayerDistance(), "Player moved while waiting.");
        assertEquals(1.0, raceManager.getFuelLevel(), "Fuel consumed while waiting.");
        if (firstOpponent != null) {
            assertEquals(initialOpponentDist + firstOpponent.getSpeed(), firstOpponent.getCurrentDistance(), 0.001);
        }

        raceManager.advanceRaceTick();
        assertFalse(raceManager.isWaiting(), "Should not be waiting after specified ticks.");

        raceManager.advanceRaceTick();
        assertEquals(PLAYER_MGR_SPEED, raceManager.getPlayerDistance(), "Player did not move after waiting period.");
    }


    @Test
    void raceFinishesWhenFuelRunsOut() {
        for (int i = 0; i < 20; i++) { // 1.0 fuel / 0.05 rate = 20 ticks
            raceManager.advanceRaceTick();
            if (raceManager.isRaceFinished()) break;
        }
        assertTrue(raceManager.isRaceFinished(), "Race should be finished due to no fuel.");
        assertEquals("Out of fuel!", raceManager.getFinishReason());
        assertEquals(0, raceManager.getFuelLevel(), 0.00001);
    }

    @Test
    void raceFinishesWhenTimeRunsOut() {
        RaceManager timeTestManager = new RaceManager(testRace, playerCar, opponents, PLAYER_MGR_SPEED, 0.0001); // Low fuel consumption
        // TEST_ROUTE (DESERT_DRIFT) duration: 15 min = 900s. 1 tick = 0.5s. Race ends after 1800 ticks.
        for (int i = 0; i < 1800; i++) {
            timeTestManager.advanceRaceTick();
            if (timeTestManager.isRaceFinished()) break;
        }
        if (!timeTestManager.isRaceFinished()) timeTestManager.advanceRaceTick();

        assertTrue(timeTestManager.isRaceFinished(), "Race should be finished due to time out.");
        if (timeTestManager.getFuelLevel() > 0) {
            assertEquals("Time ran out!", timeTestManager.getFinishReason());
        }
    }

    @Test
    void playerFinishesRaceByReachingDistance() {
        // TEST_ROUTE (DESERT_DRIFT) length: 20km. Player speed: 2.0 km/tick. Needs 10 ticks.
        for (int i = 0; i < 10; i++) {
            raceManager.advanceRaceTick();
        }
        assertTrue(raceManager.hasPlayerFinished(), "Player should have finished by distance.");
        assertTrue(raceManager.isRaceFinished());
        assertEquals("Finished the race!", raceManager.getFinishReason());
        assertEquals(10, raceManager.getPlayerFinishTick());
    }

    @Test
    void mandatoryFuelStopTriggersAndHandledWithRefuel() {
        // DESERT_DRIFT: Length 20km, 2 FuelStops. Stops at ~6.67km and ~13.33km.
        // Player speed 2.0 km/tick. First stop after 4 ticks (player at 8km).
        for (int i = 0; i < 4; i++) {
            raceManager.advanceRaceTick();
        }
        assertTrue(raceManager.isWaiting(), "Player should be waiting at fuel stop.");
        assertNotNull(raceManager.getCurrentEvent());
        assertEquals(RaceEventType.FUEL_STOP, raceManager.getCurrentEvent().getType());

        // Simulate some fuel usage before refueling by advancing a few more ticks without hitting the next stop
        // This requires the manager to not be in INDEFINITE_WAIT.
        // For this test, we assume the fuel stop was hit, now we call handleFuelStop.
        // We can't directly set fuel to an arbitrary low value.
        // Instead, let's assume fuel IS low, and test refuel's effect.
        // The refuel() method sets fuel to 1.0.

        raceManager.handleFuelStop(true); // Refuel

        assertEquals(1.0, raceManager.getFuelLevel(), "Fuel not refilled.");
        assertTrue(raceManager.isWaiting(), "Player should be waiting for refuel ticks.");
        assertNull(raceManager.getCurrentEvent(), "Fuel stop event not cleared.");

        raceManager.advanceRaceTick(); // Advance through REFUEL_WAIT_TICKS (1 tick)
        assertFalse(raceManager.isWaiting(), "Player should not be waiting after refuel ticks.");
    }

    @Test
    void mandatoryFuelStopHandledWithoutRefuel() {
        // Reach fuel stop
        for (int i = 0; i < 4; i++) raceManager.advanceRaceTick();
        assertTrue(raceManager.isWaiting());
        double fuelBeforeNoRefuel = raceManager.getFuelLevel();

        raceManager.handleFuelStop(false); // No refuel

        assertEquals(fuelBeforeNoRefuel, raceManager.getFuelLevel(), 0.0001, "Fuel level changed unexpectedly.");
        assertFalse(raceManager.isWaiting(), "Player should not be waiting.");
        assertNull(raceManager.getCurrentEvent(), "Fuel stop event not cleared.");
    }


    @Test
    void handleRepairPay() {
        raceManager.setWaiting(true, 9999); // Simulate indefinite wait for event
        int initialBalance = gameEnvironment.getBalance();
        // Assume currentEvent was BREAKDOWN for this handler to be called appropriately.
        raceManager.handleRepair(true, gameEnvironment);

        assertEquals(initialBalance - 250, gameEnvironment.getBalance(), "Repair cost not deducted."); // Using RaceManager.REPAIR_COST
        assertTrue(raceManager.isWaiting(), "Not waiting for repair ticks.");
        // Advance through REPAIR_WAIT_TICKS (2 ticks)
        raceManager.advanceRaceTick();
        raceManager.advanceRaceTick();
        assertFalse(raceManager.isWaiting(), "Still waiting after repair ticks.");
    }

    @Test
    void handleRepairNoPay() {
        raceManager.setWaiting(true, 9999);
        raceManager.handleRepair(false, gameEnvironment);
        assertTrue(raceManager.isRaceFinished());
        assertEquals("Car broke down! You withdrew from the race.", raceManager.getFinishReason());
    }

    @Test
    void handleTravelerPickUp() {
        raceManager.setWaiting(true, 9999);
        int initialBalance = gameEnvironment.getBalance();
        raceManager.handleTraveler(true, gameEnvironment);
        assertEquals(initialBalance + 250, gameEnvironment.getBalance(), "Traveler profit not added.");// Using RaceManager.TRAVELER_PROFIT
        assertTrue(raceManager.isWaiting());
        // Advance through TRAVELER_WAIT_TICKS (2 ticks)
        raceManager.advanceRaceTick();
        raceManager.advanceRaceTick();
        assertFalse(raceManager.isWaiting());
    }

    @Test
    void handleTravelerNoPickUp() {
        raceManager.setWaiting(true, 9999);
        raceManager.handleTraveler(false, gameEnvironment);
        assertFalse(raceManager.isWaiting());
    }


    @Test
    void handleWeatherEvent() {
        int initialBalance = gameEnvironment.getBalance();
        int entryFee = testRace.getCourse().getEntryFee();
        int racesRemaining = gameEnvironment.getRacesRemaining();

        raceManager.handleWeather(gameEnvironment);

        assertTrue(raceManager.isRaceCancelled());
        assertTrue(raceManager.isRaceFinished());
        assertEquals("Weather has cancelled the race!", raceManager.getFinishReason());
        assertEquals(initialBalance + entryFee, gameEnvironment.getBalance());
        assertEquals(racesRemaining + 1, gameEnvironment.getRacesRemaining());
    }

    @Test
    void getLeaderboardStandingsCorrectOrder() {
        raceManager.advanceRaceTick(); // Player: 2km, Opponents advance by their speeds
        List<LeaderboardEntry> standings = raceManager.getLeaderboardStandings();
        assertEquals(TEST_COURSE.getNumberOfOpponents() + 1, standings.size());
        assertEquals("Player", standings.get(0).getName(), "Player should be 1st.");
        if (standings.size() > 1) {
            assertTrue(standings.get(0).getDistance() >= standings.get(1).getDistance(), "Standings not sorted correctly by distance.");
        }
    }

    @Test
    void getPlayerPlacementIsCorrect() {
        raceManager.advanceRaceTick();
        assertEquals(1, raceManager.getPlayerPlacement());

        // Simulate player being slower by using a manager with slow speed
        List<OpponentCar> localOpponents = new ArrayList<>();
        localOpponents.add(new OpponentCar(0.5)); // Opponent moving at 0.5 km/tick
        RaceManager slowPlayerManager = new RaceManager(testRace, playerCar, localOpponents, 0.1, 0.01);
        slowPlayerManager.advanceRaceTick(); // Player: 0.1km. Opponent: 0.5km.
        assertEquals(2, slowPlayerManager.getPlayerPlacement());
    }

    @Test
    void getMoneyEarnedForFirstPlace() {
        for (int i = 0; i < 10; i++) raceManager.advanceRaceTick(); // Finish DESERT_DRIFT
        assertTrue(raceManager.hasPlayerFinished());
        assertEquals(1, raceManager.getPlayerPlacement()); // Assuming player is 1st
        assertEquals(TEST_COURSE.getPrizes().getFirstPlacePrize(), raceManager.getMoneyEarned());
    }

    @Test
    void deductAndAwardMoneyCorrectly() {
        Course cityCourse = Course.CITY; // Fee 1000, 1st prize 3000
        Race cityRace = new Race(cityCourse, Route.CITY_ALLEYS, TEST_DIFFICULTY); // CITY_ALLEYS length 35km
        GameEnvironment cityGameEnv = new GameEnvironment();
        cityGameEnv.setBalance(5000);
        cityGameEnv.setCurrentRace(cityRace);
        cityGameEnv.getPlayerInventory().setStarterCar(playerCar);

        // Player speed 3.0km/tick to win easily
        RaceManager cityManager = new RaceManager(cityRace, playerCar, cityRace.getOpponents(), 3.0, 0.02);

        cityManager.deductEntryFee(cityGameEnv);
        assertEquals(5000 - cityCourse.getEntryFee(), cityGameEnv.getBalance());

        for (int i = 0; i < 12; i++) cityManager.advanceRaceTick(); // 35km / 3km/tick = ~11.6 ticks => 12 ticks
        assertTrue(cityManager.hasPlayerFinished());
        assertEquals(1, cityManager.getPlayerPlacement()); // Assuming 1st

        int prize = cityManager.awardPrizeMoney(cityGameEnv);
        assertEquals(cityCourse.getPrizes().getFirstPlacePrize(), prize);
        assertEquals(5000 - cityCourse.getEntryFee() + prize, cityGameEnv.getBalance());
    }
}