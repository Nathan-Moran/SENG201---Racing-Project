package seng201.team0.unittests.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import seng201.team0.models.Car;
import seng201.team0.models.Course;
import seng201.team0.models.Difficulty;
import seng201.team0.models.OpponentCar;
import seng201.team0.models.Race;
import seng201.team0.models.Route;
import seng201.team0.services.GameEnvironment;
import seng201.team0.services.RaceManager;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class RaceManagerTest {

    private Race testRace;
    private Car playerCar;
    private List<OpponentCar> opponents;
    private OpponentCar firstOpponent; // Variable for specific opponent, if needed
    private RaceManager raceManager;
    private GameEnvironment gameEnvironment;

    private static final Route TEST_ROUTE = Route.DESERT_DRIFT; // Length: 20.0 km, Duration: 900s
    private static final Course TEST_COURSE = Course.DESERT;
    private static final Difficulty TEST_DIFFICULTY = Difficulty.EASY;

    private final double PLAYER_MGR_SPEED = 2.0; // km/tick
    private final double PLAYER_MGR_FUEL_RATE = 0.05; // per tick

    @BeforeEach
    void setUp() {
        playerCar = new Car("Player TestCar", 0.7, 0.6, 0.9, 20, 1500);
        testRace = new Race(TEST_COURSE, TEST_ROUTE, TEST_DIFFICULTY);
        opponents = testRace.getOpponents(); // Use opponents generated by Race

        // Ensure opponents list is not empty for tests that rely on opponents
        if (opponents.isEmpty()) {
            // Add a default opponent if Race does not generate any
            firstOpponent = new OpponentCar(0.1);
            opponents = new ArrayList<>(List.of(firstOpponent));
            testRace.setOpponents(opponents); // Update the race with this new list
        } else {
            firstOpponent = opponents.get(0); // If opponents are generated, get the first one
        }

        raceManager = new RaceManager(testRace, playerCar, opponents, PLAYER_MGR_SPEED, PLAYER_MGR_FUEL_RATE);

        gameEnvironment = new GameEnvironment();
        gameEnvironment.setName("JUnit Player");
        gameEnvironment.setDifficulty(TEST_DIFFICULTY);
        gameEnvironment.setBalance(10000);
        gameEnvironment.getPlayerInventory().setStarterCar(playerCar);
        gameEnvironment.setCurrentRace(testRace);
        raceManager.deductEntryFee(gameEnvironment); // Deduct entry fee in setup for consistency
    }

    @Test
    void getMoneyEarnedForFirstPlace() {
        // Run race until finished to ensure player wins
        // This loop handles potential random events or indefinite waits by continuing until race is explicitly over.
        while (!raceManager.isRaceFinished()) {
            raceManager.advanceRaceTick();
        }

        // After the race is finished, process the outcome to award prize money
        raceManager.processRaceOutcome(gameEnvironment);

        assertTrue(raceManager.hasPlayerFinished(), "Player should have finished the race.");
        // Assert player's placement. This test assumes the player wins.
        // For a robust test, you might need to ensure opponent speeds are low or player speed is very high.
        assertEquals(1, raceManager.getPlayerPlacement(), "Player should be in 1st place.");

        // Now, getMoneyEarned should include the prize money awarded in processRaceOutcome
        // Initial balance: 10000, Entry Fee: TEST_COURSE.getEntryFee() (e.g., DESERT is 500)
        // Expected money earned is just the first place prize, as no other events are guaranteed.
        assertEquals(TEST_COURSE.getPrizes().getFirstPlacePrize(), raceManager.getMoneyEarned(),
                "Money earned should be the first place prize.");
    }

    @Test
    void raceFinishesWhenTimeRunsOut() {
        // Use a low fuel consumption rate to ensure time runs out before fuel
        RaceManager timeTestManager = new RaceManager(testRace, playerCar, opponents, PLAYER_MGR_SPEED, 0.00001);

        // Run race until finished. The loop will break when a race-ending condition is met.
        while (!timeTestManager.isRaceFinished()) {
            timeTestManager.advanceRaceTick();
        }

        assertTrue(timeTestManager.isRaceFinished(), "Race should be finished due to time out.");

        // Check if the finish reason is "Time ran out!".
        // It's possible fuel could also run out if the fuel consumption was slightly higher
        // or the duration was very long without refuels.
        assertEquals("Time ran out!", timeTestManager.getFinishReason(),
                "Race should end because time ran out.");

        // Verify fuel level (it should still be positive if time ran out first)
        assertTrue(timeTestManager.getFuelLevel() > 0, "Fuel should not have run out before time.");
    }

    @Test
    void deductAndAwardMoneyCorrectly() {
        Course cityCourse = Course.CITY; // Example: Fee 1000, 1st prize 3000
        Race cityRace = new Race(cityCourse, Route.CITY_ALLEYS, TEST_DIFFICULTY); // CITY_ALLEYS length 35km
        GameEnvironment cityGameEnv = new GameEnvironment();
        cityGameEnv.setBalance(5000); // Initial balance for this specific test
        cityGameEnv.setCurrentRace(cityRace);
        cityGameEnv.getPlayerInventory().setStarterCar(playerCar);

        // Player speed 3.0km/tick to ensure easy win and finish by distance
        // Fuel rate is set low to avoid fuel running out first
        RaceManager cityManager = new RaceManager(cityRace, playerCar, cityRace.getOpponents(), 3.0, 0.0001);

        // Deduct entry fee before the race starts for this test
        cityManager.deductEntryFee(cityGameEnv);
        assertEquals(5000 - cityCourse.getEntryFee(), cityGameEnv.getBalance(), "Balance after entry fee deduction.");

        // Run race until finished. Player speed 3.0km/tick, length 35km, ~11.6 ticks.
        // A while loop ensures it continues until the race is over, handling any delays.
        while (!cityManager.isRaceFinished()) {
            cityManager.advanceRaceTick();
        }

        // Process outcome to award prize money and update all relevant game environment stats
        cityManager.processRaceOutcome(cityGameEnv);

        assertTrue(cityManager.hasPlayerFinished(), "Player should have finished the race.");
        assertEquals(1, cityManager.getPlayerPlacement(), "Player should be in 1st place.");

        // moneyEarned in RaceManager should reflect the prize money (assuming no random events added profit)
        int prize = cityManager.getMoneyEarned();
        assertEquals(cityCourse.getPrizes().getFirstPlacePrize(), prize, "RaceManager's moneyEarned should be the 1st place prize.");

        // GameEnvironment balance should reflect initial balance - entry fee + prize money
        assertEquals(5000 - cityCourse.getEntryFee() + prize, cityGameEnv.getBalance(),
                "GameEnvironment balance should be updated correctly.");
    }

    @Test
    void playerFinishesRaceByReachingDistance() {
        // TEST_ROUTE (DESERT_DRIFT) length: 20km. Player speed: 2.0 km/tick. Needs 10 ticks.
        // To ensure this test specifically passes due to distance, we need to minimize
        // the chances of random events or fuel/time ending the race prematurely.
        // For unit testing, a common approach is to mock the Random object in RaceManager
        // so it doesn't trigger events, or temporarily adjust event trigger distances.
        // If you don't have control over `Random` or event distances for testing,
        // this test might still fail if a random event causes an `INDEFINITE_WAIT`.

        // For this example, we'll assume a robust loop, but acknowledge random events are a factor.
        // Let's also adjust fuel consumption to be very low, and set duration very high for testing this path.
        RaceManager distanceTestManager = new RaceManager(testRace, playerCar, opponents, PLAYER_MGR_SPEED, 0.00001);
        // This is a simplified way if you can't easily change `race.getRoute().getRaceDuration()` for testing.
        // Otherwise, setting a very high race duration on the Route object itself would be better.

        while (!distanceTestManager.isRaceFinished()) {
            distanceTestManager.advanceRaceTick();
        }

        assertTrue(distanceTestManager.hasPlayerFinished(), "Player should have finished by distance.");
        assertTrue(distanceTestManager.isRaceFinished(), "Race should be marked as finished.");
        assertEquals("Finished the race!", distanceTestManager.getFinishReason(),
                "Finish reason should be 'Finished the race!'.");

        // The playerFinishTick logic: tickCount increments at the start of advanceRaceTick, then distance is added,
        // then finish is checked. So if it finishes *on* the 10th tick, tickCount will be 10.
        // This assertion might be sensitive to floating-point precision or event interruptions.
        assertEquals(10, distanceTestManager.getPlayerFinishTick(),
                "Player should finish exactly on the 10th tick.");
    }

    @Test
    void raceFinishesWhenFuelRunsOut() {
        // Player speed is set to ensure fuel runs out before distance is covered.
        // Original: 1.0 fuel / 0.05 rate = 20 ticks. Length 20km. Speed 2.0 km/tick.
        // So, player covers 20km in 10 ticks, but runs out of fuel in 20 ticks.
        // This means, by default, the player will finish by distance before running out of fuel.
        // To force fuel to run out *first*, increase fuel consumption rate or decrease speed.
        // Let's use a higher fuel consumption rate for this specific test.
        RaceManager fuelTestManager = new RaceManager(testRace, playerCar, opponents, 0.1, 0.1); // Low speed, high fuel

        while (!fuelTestManager.isRaceFinished()) {
            fuelTestManager.advanceRaceTick();
        }

        assertTrue(fuelTestManager.isRaceFinished(), "Race should be finished due to no fuel.");
        assertEquals("Out of fuel!", fuelTestManager.getFinishReason(),
                "Race should end because fuel ran out.");
        assertEquals(0, fuelTestManager.getFuelLevel(), 0.00001,
                "Fuel level should be zero.");
    }
}